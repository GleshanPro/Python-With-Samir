"""

Неминуемо будем ходить на стажи.

HR слишком оптимистично настроены насчёт рынка (Самир их ненавидит, мы тоже будем)
Подкасты про собесы кто-нибудь смотрел? Офферы? (Требования нереальные - требуют опыт работы, который мы не можем получить, если не можем устроиться)

Замкнутая петля - что делать? - Накрутка годов опыта.

Pipeline собеса:
1. Общение насчёт резюме (технологии, опыт в проектах, pet-проекты (github ссылка) - уже стоит начинать)
   Роль, стэк технологий рассказать
   
- Попадаем на потенциальный технический собес
(Видосик, как происходит найм в Яндексе 
1. Два алго собеса
2. Тех собес
3. Скрининг в команде)

LeetCode в задачках - не просто так.
Алго собесы содержат подобные Easy-Medium (особенно 1/2 часть собеса)
Очень редко Hard
Самые популярные - строки, дин прога, жадное прог, графы и деревья

Решил за О(n^2)? - Перерешивай! (если есть более оптимальное решение)


"""


seen = (1,)

# Считаем остаток в множестве - надо почитать про то, как считается индекс
# probbing
# хэш-таблица должна проверять равенство: два разных числа могут обладать одним хэшом,
# но сравнить хэш - недостаточно

# 2**64 - длинные числа, не умещаюстя в регистре (узнаем на 2 курсе)
# Их сравнение - не константа, не O(1)

def two_sum(nums, target):
    seen = {} # В худшем случае ПАМЯТЬ O(n)
    for num in nums:
        # target - num можем дать хэш, который есть в seen, но значение другое - probbing
        # тогда O(n)
        if target - num in seen: # O(1) - если нет коллизий (да, их очень мало, но тем не менее на high-load такое неминуемо) - МЫ ВСЕГДА ДОЛЖНЫ ДАВАТЬ ПОЛНЫЙ ОТВЕТ НА ВОПРОС
            return True
        seen.add(num)
        
# Если гарантированно, что список сортирован - используем два указателя
# Сложность также O(n), а память O(1)
# Иногда мы говорим: "Давайте сначала сорт посл, потом решим задачу"
def two_sum_sorted(nums, target):
    left, right = 0, len(nums) - 1
    while left < right:
        if nums[left] + nums[right] == target:
            return True
        elif nums[left] + nums[right] < target:
            left += 1
        else:
            right -= 1
    return False


# Чем 2 сум отличается от 3 сум?
    
# Нет аргументов в подтверждение своей позиции? - Не спорь с интервьюером.
# Что-то пишешь? - Будь готов отвечать за то, что ты пишешь.
# Поэтому я запрещаю вам ГПТ.
# Можете читать StackOverFlow. Вы читаете, хотя бы что-то на корке мозга остаётся.
# А ГПТ - Ctrl+C, Ctrl+v


"""
Radix Sort с Bucket неэффективно сортировать числа вида
1_000_000_000

"""

def three_sum(nums, target):
    """
    Поиск:
    1. hash
    2. остаток от размера - получили индекс
    3. Переходим к значению под индексом - там лежат данные (ключ: значение)
    4. Они равны - нашли, не нашли - коллизия - искать далее, будет уже не O(1) а O(k)
    
    (материалы Самира)
    Борьба с коллизией:
    1. Цепочка - связный список
    
    hash(123124) -> 1 -> 2 -> 3
    
    2. Открытая адресация
    Вместо держать все значения, давайте при коллизии записывать значение в следующую ячейку
    (итерирование)
    
    Python: линейная (открытая) адресация и открытое пробирование (пытаемся вставить в след пустую позицию после эл)
    Из-за открытой есть сложности со сложностной оценкой
    
    """
    
    
    """
    Коэф зап множества перед реаллокацией - 2/3
    
    Словари - обычно от 1/3 до 2/3 (причём зачастую в коде 1/3) - дальше РЕХЕШИРОВАНИЕ (почитать, что это)
    Порядок в словарях сейчас гарантируется, раньше нет - НЕ НАДО НА ЭТО УПИРАТЬСЯ
    Лучше использовать OrderDict - он
    Implementation detail в текущих реализацяих пайтона это гарантируестся, но в след версиях не обязательно 
     Сейчас полноценно сказать, что онгарнтируется нельзя
    
    
    """
    # Вернуть позиции элементов дающих target
    nums.sort() # n log n - использовать cnt или другое - попытка оптимизировать неоптимизируемое
    dictionary = {} # Начиная с python 3.6 микрооптимизация разнесены ключи и значения
    # Выделяется 8 ячеек
    for pivot in range(0, len(nums)): # (Я: мини опт len(nums) - 2)
        flag = two_sum_sorted(nums[pivot + 1:], target-nums[pivot])
        if flag:
            return True
    return False


"""
СОБЕС на ExcaliDraw

list.appind() - ну, опечатался. Не должны придраться.
НУЖНО НАУЧИТЬСЯ БЕЗ IDE ИСКАТЬ ПОДСКАЗКИ

"""


"""
Самописный event-loop (что это?)
"""
                
        
"""
Собес:
- вкл камеру, шарим экран
- 2 теор вопроса
- 1 задача
    - код неопт? уточняющие вопросы
- Самир смотрит что и как отвечали
- говорит оценку


- Объясните как работает множетсво
вставка в список
декоратор
почему нельзя использовать неизменяемые коллекции в качестве значения по умолчанию

"""
    